<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gbif_dl.generators.dwca API documentation</title>
<meta name="description" content="This module creates the interface to the GBIF API via a [download/doi functionality](https://www.gbif.org/data-processing).
Give a link to a GBIF …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gbif_dl.generators.dwca</code></h1>
</header>
<section id="section-intro">
<p>This module creates the interface to the GBIF API via a <a href="https://www.gbif.org/data-processing">download/doi functionality</a>.
Give a link to a GBIF darwincore archive, users can use this module to obtain lists of urls of media data
to be downloaded using the <a href="gbif_dl.io">io</a> module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/plantnet/gbif-dl/blob/5c00725e4e433dca28393b7f6f9b4058b8c6437e/gbif_dl/generators/dwca.py#L1-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module creates the interface to the GBIF API via a [download/doi functionality](https://www.gbif.org/data-processing).
Give a link to a GBIF darwincore archive, users can use this module to obtain lists of urls of media data 
to be downloaded using the [io](gbif_dl.io) module.
&#34;&#34;&#34;

import pygbif
from pathlib import Path
import random
import requests
import hashlib
import re
import tempfile
from typing import Optional
import os

from ..stores import MediaData

from dwca.read import DwCAReader
from typing import Optional

mmqualname = &#34;http://purl.org/dc/terms/&#34;
gbifqualname = &#34;http://rs.gbif.org/terms/1.0/&#34;


def dwca_generator(
    dwca_path: str,
    label: str = &#34;speciesKey&#34;,
    mediatype: str = &#34;StillImage&#34;,
    license_info: bool = True,
    one_media_per_occurrence: bool = True,
    delete: Optional[bool] = False,
) -&gt; MediaData:
    &#34;&#34;&#34;Yields media urls from GBIF Darwin Core Archive

    Args:
        dwca_path (str): path to darwin core zip file
        label (str, optional): Output label name. Defaults to &#34;speciesKey&#34;.
        mediatype (str, optional): Media type. Defaults to &#39;StillImage&#39;.
        license_info (bool): retrieve images license information. Default to True.
        one_media_per_occurrence (bool): only retrieve one media in multiple media occurrences. Default to True,
        delete (bool, optional): Delete darwin core archive when finished.

    Yields:
        Dict: Item dictionary
    &#34;&#34;&#34;
    with DwCAReader(dwca_path) as dwca:
        for row in dwca:
            img_extensions = []
            for ext in row.extensions:
                # multiple images are handled as multiple extensions
                # therefore lets filter the images first and then
                # yield a random one
                if ext.rowtype == gbifqualname + &#34;Multimedia&#34;:
                    if ext.data[mmqualname + &#34;type&#34;] == mediatype:
                        img_extensions.append(ext.data)

            if one_media_per_occurrence:
                media = [random.choice(img_extensions)]
            else:
                media = img_extensions

            for selected_img in media:
                url = selected_img.get(mmqualname + &#34;identifier&#34;, None)
                if url:
                    # hash the url, which later becomes the datatype
                    hashed_url = hashlib.sha1(url.encode(&#34;utf-8&#34;)).hexdigest()

                    if label is not None:
                        output_label = str(row.data.get(gbifqualname + label))
                        if output_label is None or not output_label:
                            continue
                    else:
                        output_label = row.data

                    media_data = {
                        &#34;url&#34;: url,
                        &#34;basename&#34;: hashed_url,
                        &#34;label&#34;: output_label,
                    }
                    if license_info:
                        media_data[&#34;publisher&#34;] = selected_img.get(mmqualname + &#34;publisher&#34;, None)
                        media_data[&#34;license&#34;] = selected_img.get(mmqualname + &#34;license&#34;, None)
                        media_data[&#34;rightsHolder&#34;] = selected_img.get(
                            mmqualname + &#34;rightsHolder&#34;,
                            selected_img.get(mmqualname + &#34;creator&#34;, None),
                        )

                    yield media_data

    if delete:
        os.remove(dwca_path)


def doi_to_gbif_key(doi: str) -&gt; str:
    &#34;&#34;&#34;get gbif download id from doi

    Args:
        doi (str): doi string (not full url)

    Returns:
        str: gbif id
    &#34;&#34;&#34;
    r = requests.get(&#34;https://api.datacite.org/dois/&#34; + doi)
    if r.status_code == requests.codes.ok:
        gbif_url = r.json().get(&#34;data&#34;).get(&#34;attributes&#34;).get(&#34;url&#34;)
        if gbif_url is not None:
            gbif_key = gbif_url.split(&#34;/&#34;)[-1]
            if bool(re.match(&#34;^[0-9\-]*$&#34;, gbif_key)):
                return gbif_key


def is_doi(identifier: str) -&gt; bool:
    &#34;&#34;&#34;Validates if identifier is a valid DOI

    Args:
        identifier (str): potential doi string

    Returns:
        bool: true if identifier is a valid DOI
    &#34;&#34;&#34;
    doi_patterns = [
        r&#34;(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?![\&#34;&amp;\&#39;])\S)+)&#34;,
        r&#34;(10.\d{4,9}/[-._;()/:A-Z0-9]+)&#34;,
        r&#34;(10.\d{4}/\d+-\d+X?(\d+)\d+&lt;[\d\w]+:[\d\w]*&gt;\d+.\d+.\w+;\d)&#34;,
        r&#34;(10.1021/\w\w\d+)&#34;,
        r&#34;(10.1207/[\w\d]+\&amp;\d+_\d+)&#34;,
    ]
    for pattern in doi_patterns:
        match = bool(re.match(pattern, identifier))
        if match:
            return True
    return False


def generate_urls(
    identifier: str,
    dwca_root_path=None,
    label: Optional[str] = None,
    mediatype: Optional[str] = &#34;StillImage&#34;,
    license_info: bool = True,
    one_media_per_occurrence: bool = True,
    delete: Optional[bool] = False,
):
    &#34;&#34;&#34;Generate GBIF items from DOI or GBIF download key

    Args:
        identifier (str): doi or gbif key
        dwca_root_path (str, optional): Set root path where to store
            Darwin Core zip files. Defaults to None, which results in
            the creation of temporary directries
        label (str, optional): Output label name.
            Defaults to `None` which yields all metadata.
        mediatype (str, optional): Sets GBIF mediatype. Defaults to &#39;StillImage&#39;.
            the creation of temporary directories.
        license_info (bool): retrieve images license information. Default to True.
        one_media_per_occurrence (bool): only retrieve one media in multiple media occurrences. Default to True,

        delete (bool, optional): Delete darwin core archive when finished.

    Returns:
        Iterable: item generator that yields files from generator
    &#34;&#34;&#34;
    if is_doi:
        key = doi_to_gbif_key(identifier)
    else:
        key = identifier

    if dwca_root_path is None:
        dwca_root_path = tempfile.mkdtemp()

    # download darwin core archive
    dwca_root_path = Path(dwca_root_path)
    dwca_root_path.mkdir(parents=True, exist_ok=True)
    dwca_path = Path(dwca_root_path, key + &#34;.zip&#34;)
    if not dwca_path.exists():
        r = pygbif.occurrences.download_get(key=key, path=dwca_root_path)
        dwca_path = r[&#34;path&#34;]

    # extract media urls and return item generator
    return dwca_generator(
        dwca_path=dwca_path,
        label=label,
        mediatype=mediatype,
        one_media_per_occurrence=one_media_per_occurrence,
        license_info=license_info,
        delete=delete,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gbif_dl.generators.dwca.doi_to_gbif_key"><code class="name flex">
<span>def <span class="ident">doi_to_gbif_key</span></span>(<span>doi: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>get gbif download id from doi</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doi</code></strong> :&ensp;<code>str</code></dt>
<dd>doi string (not full url)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>gbif id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/plantnet/gbif-dl/blob/5c00725e4e433dca28393b7f6f9b4058b8c6437e/gbif_dl/generators/dwca.py#L95-L110" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doi_to_gbif_key(doi: str) -&gt; str:
    &#34;&#34;&#34;get gbif download id from doi

    Args:
        doi (str): doi string (not full url)

    Returns:
        str: gbif id
    &#34;&#34;&#34;
    r = requests.get(&#34;https://api.datacite.org/dois/&#34; + doi)
    if r.status_code == requests.codes.ok:
        gbif_url = r.json().get(&#34;data&#34;).get(&#34;attributes&#34;).get(&#34;url&#34;)
        if gbif_url is not None:
            gbif_key = gbif_url.split(&#34;/&#34;)[-1]
            if bool(re.match(&#34;^[0-9\-]*$&#34;, gbif_key)):
                return gbif_key</code></pre>
</details>
</dd>
<dt id="gbif_dl.generators.dwca.dwca_generator"><code class="name flex">
<span>def <span class="ident">dwca_generator</span></span>(<span>dwca_path: str, label: str = 'speciesKey', mediatype: str = 'StillImage', license_info: bool = True, one_media_per_occurrence: bool = True, delete: Optional[bool] = False) ‑> <a title="gbif_dl.stores.MediaData" href="../stores/index.html#gbif_dl.stores.MediaData">MediaData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Yields media urls from GBIF Darwin Core Archive</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dwca_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to darwin core zip file</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Output label name. Defaults to "speciesKey".</dd>
<dt><strong><code>mediatype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Media type. Defaults to 'StillImage'.</dd>
<dt><strong><code>license_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>retrieve images license information. Default to True.</dd>
<dt><strong><code>one_media_per_occurrence</code></strong> :&ensp;<code>bool</code></dt>
<dd>only retrieve one media in multiple media occurrences. Default to True,</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Delete darwin core archive when finished.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Item dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/plantnet/gbif-dl/blob/5c00725e4e433dca28393b7f6f9b4058b8c6437e/gbif_dl/generators/dwca.py#L26-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dwca_generator(
    dwca_path: str,
    label: str = &#34;speciesKey&#34;,
    mediatype: str = &#34;StillImage&#34;,
    license_info: bool = True,
    one_media_per_occurrence: bool = True,
    delete: Optional[bool] = False,
) -&gt; MediaData:
    &#34;&#34;&#34;Yields media urls from GBIF Darwin Core Archive

    Args:
        dwca_path (str): path to darwin core zip file
        label (str, optional): Output label name. Defaults to &#34;speciesKey&#34;.
        mediatype (str, optional): Media type. Defaults to &#39;StillImage&#39;.
        license_info (bool): retrieve images license information. Default to True.
        one_media_per_occurrence (bool): only retrieve one media in multiple media occurrences. Default to True,
        delete (bool, optional): Delete darwin core archive when finished.

    Yields:
        Dict: Item dictionary
    &#34;&#34;&#34;
    with DwCAReader(dwca_path) as dwca:
        for row in dwca:
            img_extensions = []
            for ext in row.extensions:
                # multiple images are handled as multiple extensions
                # therefore lets filter the images first and then
                # yield a random one
                if ext.rowtype == gbifqualname + &#34;Multimedia&#34;:
                    if ext.data[mmqualname + &#34;type&#34;] == mediatype:
                        img_extensions.append(ext.data)

            if one_media_per_occurrence:
                media = [random.choice(img_extensions)]
            else:
                media = img_extensions

            for selected_img in media:
                url = selected_img.get(mmqualname + &#34;identifier&#34;, None)
                if url:
                    # hash the url, which later becomes the datatype
                    hashed_url = hashlib.sha1(url.encode(&#34;utf-8&#34;)).hexdigest()

                    if label is not None:
                        output_label = str(row.data.get(gbifqualname + label))
                        if output_label is None or not output_label:
                            continue
                    else:
                        output_label = row.data

                    media_data = {
                        &#34;url&#34;: url,
                        &#34;basename&#34;: hashed_url,
                        &#34;label&#34;: output_label,
                    }
                    if license_info:
                        media_data[&#34;publisher&#34;] = selected_img.get(mmqualname + &#34;publisher&#34;, None)
                        media_data[&#34;license&#34;] = selected_img.get(mmqualname + &#34;license&#34;, None)
                        media_data[&#34;rightsHolder&#34;] = selected_img.get(
                            mmqualname + &#34;rightsHolder&#34;,
                            selected_img.get(mmqualname + &#34;creator&#34;, None),
                        )

                    yield media_data

    if delete:
        os.remove(dwca_path)</code></pre>
</details>
</dd>
<dt id="gbif_dl.generators.dwca.generate_urls"><code class="name flex">
<span>def <span class="ident">generate_urls</span></span>(<span>identifier: str, dwca_root_path=None, label: Optional[str] = None, mediatype: Optional[str] = 'StillImage', license_info: bool = True, one_media_per_occurrence: bool = True, delete: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate GBIF items from DOI or GBIF download key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>doi or gbif key</dd>
<dt><strong><code>dwca_root_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set root path where to store
Darwin Core zip files. Defaults to None, which results in
the creation of temporary directries</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Output label name.
Defaults to <code>None</code> which yields all metadata.</dd>
<dt><strong><code>mediatype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Sets GBIF mediatype. Defaults to 'StillImage'.
the creation of temporary directories.</dd>
<dt><strong><code>license_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>retrieve images license information. Default to True.</dd>
<dt><strong><code>one_media_per_occurrence</code></strong> :&ensp;<code>bool</code></dt>
<dd>only retrieve one media in multiple media occurrences. Default to True,</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Delete darwin core archive when finished.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable</code></dt>
<dd>item generator that yields files from generator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/plantnet/gbif-dl/blob/5c00725e4e433dca28393b7f6f9b4058b8c6437e/gbif_dl/generators/dwca.py#L136-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_urls(
    identifier: str,
    dwca_root_path=None,
    label: Optional[str] = None,
    mediatype: Optional[str] = &#34;StillImage&#34;,
    license_info: bool = True,
    one_media_per_occurrence: bool = True,
    delete: Optional[bool] = False,
):
    &#34;&#34;&#34;Generate GBIF items from DOI or GBIF download key

    Args:
        identifier (str): doi or gbif key
        dwca_root_path (str, optional): Set root path where to store
            Darwin Core zip files. Defaults to None, which results in
            the creation of temporary directries
        label (str, optional): Output label name.
            Defaults to `None` which yields all metadata.
        mediatype (str, optional): Sets GBIF mediatype. Defaults to &#39;StillImage&#39;.
            the creation of temporary directories.
        license_info (bool): retrieve images license information. Default to True.
        one_media_per_occurrence (bool): only retrieve one media in multiple media occurrences. Default to True,

        delete (bool, optional): Delete darwin core archive when finished.

    Returns:
        Iterable: item generator that yields files from generator
    &#34;&#34;&#34;
    if is_doi:
        key = doi_to_gbif_key(identifier)
    else:
        key = identifier

    if dwca_root_path is None:
        dwca_root_path = tempfile.mkdtemp()

    # download darwin core archive
    dwca_root_path = Path(dwca_root_path)
    dwca_root_path.mkdir(parents=True, exist_ok=True)
    dwca_path = Path(dwca_root_path, key + &#34;.zip&#34;)
    if not dwca_path.exists():
        r = pygbif.occurrences.download_get(key=key, path=dwca_root_path)
        dwca_path = r[&#34;path&#34;]

    # extract media urls and return item generator
    return dwca_generator(
        dwca_path=dwca_path,
        label=label,
        mediatype=mediatype,
        one_media_per_occurrence=one_media_per_occurrence,
        license_info=license_info,
        delete=delete,
    )</code></pre>
</details>
</dd>
<dt id="gbif_dl.generators.dwca.is_doi"><code class="name flex">
<span>def <span class="ident">is_doi</span></span>(<span>identifier: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates if identifier is a valid DOI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>potential doi string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if identifier is a valid DOI</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/plantnet/gbif-dl/blob/5c00725e4e433dca28393b7f6f9b4058b8c6437e/gbif_dl/generators/dwca.py#L113-L133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_doi(identifier: str) -&gt; bool:
    &#34;&#34;&#34;Validates if identifier is a valid DOI

    Args:
        identifier (str): potential doi string

    Returns:
        bool: true if identifier is a valid DOI
    &#34;&#34;&#34;
    doi_patterns = [
        r&#34;(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?![\&#34;&amp;\&#39;])\S)+)&#34;,
        r&#34;(10.\d{4,9}/[-._;()/:A-Z0-9]+)&#34;,
        r&#34;(10.\d{4}/\d+-\d+X?(\d+)\d+&lt;[\d\w]+:[\d\w]*&gt;\d+.\d+.\w+;\d)&#34;,
        r&#34;(10.1021/\w\w\d+)&#34;,
        r&#34;(10.1207/[\w\d]+\&amp;\d+_\d+)&#34;,
    ]
    for pattern in doi_patterns:
        match = bool(re.match(pattern, identifier))
        if match:
            return True
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gbif_dl.generators" href="index.html">gbif_dl.generators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gbif_dl.generators.dwca.doi_to_gbif_key" href="#gbif_dl.generators.dwca.doi_to_gbif_key">doi_to_gbif_key</a></code></li>
<li><code><a title="gbif_dl.generators.dwca.dwca_generator" href="#gbif_dl.generators.dwca.dwca_generator">dwca_generator</a></code></li>
<li><code><a title="gbif_dl.generators.dwca.generate_urls" href="#gbif_dl.generators.dwca.generate_urls">generate_urls</a></code></li>
<li><code><a title="gbif_dl.generators.dwca.is_doi" href="#gbif_dl.generators.dwca.is_doi">is_doi</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>